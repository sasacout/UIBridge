// Auto-generated by UIBridge. Do not edit manually.

import React from "react";

const widgetMap = {
  Container: "div",
  Button: "button",
  Label: "p", // block for multiline
  Image: "img",
  ImageSeqOpt: "div",// Auto-generated by UIBridge. Do not edit manually.

import React from "react";

const widgetMap = {
  Container: "div",
  Button: "button",
  Label: "p", // block for multiline
  Image: "img",
  ImageSeqOpt: "div",
};

function toCamel(s) {
  return s.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
}

// Tailwind로 커버되는 스타일은 className에, 나머지는 style에만 분리
function buildTailwind(widget, styleUsed) {
  let cls = widget.tailwind ? widget.tailwind.trim() + " " : "";
  const L = widget.layout || {};
  if (typeof L.x === "number" || typeof L.y === "number") {
    cls += "absolute ";
    if (typeof L.x === "number") cls += `left-[${L.x}px] `;
    if (typeof L.y === "number") cls += `top-[${L.y}px] `;
  }
  if (typeof L.w === "number") cls += `w-[${L.w}px] `;
  if (typeof L.h === "number") cls += `h-[${L.h}px] `;

  if (widget.type === "Container" && widget.children && widget.children.length > 0) cls += "flex flex-col ";

  const S = widget.style || {};
  if (S.color) {
    const hex = ("" + S.color).split(" ")[0];
    cls += /^#/.test(hex) ? `text-[${hex}] ` : `text-${hex} `;
    if (styleUsed) styleUsed.color = true;
  }
  if (S.fontSize) {
    const size = typeof S.fontSize === "number" ? `${S.fontSize}px` : S.fontSize;
    cls += `text-[${size}] `;
    if (styleUsed) styleUsed.fontSize = true;
  }
  if (S.textAlign) {
    const ta = ("" + S.textAlign).toLowerCase();
    if (["left", "center", "right", "justify"].includes(ta)) cls += `text-${ta} `;
    if (styleUsed) styleUsed.textAlign = true;
  }
  if (widget.text && widget.text.indexOf("\n") !== -1) cls += "whitespace-pre-line ";

  return cls.trim();
}

function buildInlineStyle(widget, styleUsed) {
  const S = widget.style || {};
  const style = {};
  for (const [k, v] of Object.entries(S)) {
    if (styleUsed && styleUsed[k]) continue; // Tailwind로 이미 처리된 스타일 제외
    if (k === "color" && typeof v === "string") {
      const [hex, alpha] = v.split(" ");
      style[toCamel(k)] = hex;
      if (alpha) style.opacity = parseFloat(alpha) / 100;
    } else if (k === "fontSize" && typeof v === "number") {
      style[toCamel(k)] = `${v}px`;
    } else {
      style[toCamel(k)] = v;
    }
  }
  return Object.keys(style).length ? style : undefined;
}

export function irToReact(ir, widgetMapOverride = {}) {
  if (!ir || !ir.widgets) return null;

  const byId = {};
  ir.widgets.forEach(w => (byId[w.id] = w));

  // 모든 children ID를 모아 root 판단
  const allIds = new Set(ir.widgets.map(w => w.id));
  const childIds = new Set(ir.widgets.flatMap(w => w.children || []));
  const roots = ir.widgets.filter(w => w.type === "Container" && !childIds.has(w.id));
  if (!roots.length) roots.push(ir.widgets[0]);

  function render(widget) {
    const CompTag = widgetMapOverride[widget.type] || widgetMap[widget.type] || "div";
    const styleUsed = {};
    const className = buildTailwind(widget, styleUsed);
    const style = buildInlineStyle(widget, styleUsed);
    const props = { id: widget.id };
    if (className) props.className = className;
    if (style) props.style = style;
    if (widget.type === "Image" && widget.src) {
      props.src = widget.src;
      props.alt = widget.id;
    }

    // children 처리: text 줄바꿈 반영 + child widget 렌더링
    const children = [];
    if (widget.text) {
      widget.text.split("\n").forEach((line, i) => {
        if (i > 0) children.push(<br key={i} />);
        children.push(line);
      });
    }
    if (widget.children && widget.children.length > 0) {
      widget.children.forEach(cid => {
        const c = byId[cid];
        if (c) children.push(render(c));
      });
    }

    return React.createElement(CompTag, props, children.length ? children : null);
  }

  return (
    <>
      {roots.map(root => render(root))}
    </>
  );
}

};

function toCamel(s) {
  return s.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
}

// Tailwind로 커버되는 스타일은 className에, 나머지는 style에만 분리
function buildTailwind(widget, styleUsed) {
  let cls = widget.tailwind ? widget.tailwind.trim() + " " : "";
  const L = widget.layout || {};
  if (typeof L.x === "number" || typeof L.y === "number") {
    cls += "absolute ";
    if (typeof L.x === "number") cls += `left-[${L.x}px] `;
    if (typeof L.y === "number") cls += `top-[${L.y}px] `;
  }
  if (typeof L.w === "number") cls += `w-[${L.w}px] `;
  if (typeof L.h === "number") cls += `h-[${L.h}px] `;

  if (widget.type === "Container" && widget.children && widget.children.length > 0) cls += "flex flex-col ";

  const S = widget.style || {};
  if (S.color) {
    const hex = ("" + S.color).split(" ")[0];
    cls += /^#/.test(hex) ? `text-[${hex}] ` : `text-${hex} `;
    if (styleUsed) styleUsed.color = true;
  }
  if (S.fontSize) {
    const size = typeof S.fontSize === "number" ? `${S.fontSize}px` : S.fontSize;
    cls += `text-[${size}] `;
    if (styleUsed) styleUsed.fontSize = true;
  }
  if (S.textAlign) {
    const ta = ("" + S.textAlign).toLowerCase();
    if (["left", "center", "right", "justify"].includes(ta)) cls += `text-${ta} `;
    if (styleUsed) styleUsed.textAlign = true;
  }
  if (widget.text && widget.text.indexOf("\n") !== -1) cls += "whitespace-pre-line ";

  return cls.trim();
}

function buildInlineStyle(widget, styleUsed) {
  const S = widget.style || {};
  const style = {};
  for (const [k, v] of Object.entries(S)) {
    if (styleUsed && styleUsed[k]) continue; // Tailwind로 이미 처리된 스타일 제외
    if (k === "color" && typeof v === "string") {
      const [hex, alpha] = v.split(" ");
      style[toCamel(k)] = hex;
      if (alpha) style.opacity = parseFloat(alpha) / 100;
    } else if (k === "fontSize" && typeof v === "number") {
      style[toCamel(k)] = `${v}px`;
    } else {
      style[toCamel(k)] = v;
    }
  }
  return Object.keys(style).length ? style : undefined;
}

export function irToReact(ir, widgetMapOverride = {}) {
  if (!ir || !ir.widgets) return null;

  const byId = {};
  ir.widgets.forEach(w => (byId[w.id] = w));

  // root container 선택 강화 (screenId 포함 및 _sketch suffix 대응)
  let root = ir.widgets.find(
    w =>
      w.type === "Container" &&
      ir.screenId &&
      (w.id.startsWith(ir.screenId) || w.id.startsWith(ir.screenId + "_sketch"))
  );
  if (!root) root = ir.widgets.find(w => w.type === "Container") || ir.widgets[0];
  if (!root) return null;

  function render(widget) {
    const CompTag = widgetMapOverride[widget.type] || widgetMap[widget.type] || "div";
    const styleUsed = {};
    const className = buildTailwind(widget, styleUsed);
    const style = buildInlineStyle(widget, styleUsed);
    const props = { id: widget.id };
    if (className) props.className = className;
    if (style) props.style = style;
    if (widget.type === "Image" && widget.src) {
      props.src = widget.src;
      props.alt = widget.id;
    }

    // children 처리: text 줄바꿈 반영 + child widget 렌더링
    const children = [];
    if (widget.text) {
      widget.text.split("\n").forEach((line, i) => {
        if (i > 0) children.push(<br key={i} />);
        children.push(line);
      });
    }
    if (widget.children && widget.children.length > 0) {
      widget.children.forEach(cid => {
        const c = byId[cid] || byId[cid.replace(/_sketch\d*$/, "")]; // _sketch fallback
        if (c) children.push(render(c));
      });
    }

    if (CompTag === "img") return React.createElement("img", props);
    return React.createElement(CompTag, props, children.length ? children : null);
  }

  return render(root);
}
