// Auto-generated by UIBridge. Do not edit manually.

/**
 * IR 객체를 받아 JSX 코드(문자열)로 변환합니다.
 * @param {object} ir - Intermediate Representation
 * @param {string} screenName - 생성할 컴포넌트 이름
 * @returns {string} JSX 코드
 */
export function irToJsx(ir, screenName = "ScreenMain") {
  if (!ir || !ir.widgets || ir.widgets.length === 0) return "";

  function toCamel(s) {
    return s.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
  }

  function widgetToTailwind(widget, styleUsed) {
    let cls = widget.tailwind ? widget.tailwind.trim() + " " : "";
    const L = widget.layout || {};
    if (typeof L.x === "number" || typeof L.y === "number") {
      cls += "absolute ";
      if (typeof L.x === "number") cls += `left-[${L.x}px] `;
      if (typeof L.y === "number") cls += `top-[${L.y}px] `;
    }
    if (typeof L.w === "number") cls += `w-[${L.w}px] `;
    if (typeof L.h === "number") cls += `h-[${L.h}px] `;
    if (widget.type === "Container" && widget.children?.length) cls += "flex flex-col ";

    const S = widget.style || {};
    if (S.color) {
      const hex = ("" + S.color).split(" ")[0];
      cls += /^#/.test(hex) ? `text-[${hex}] ` : `text-${hex} `;
      if (styleUsed) styleUsed.color = true;
    }
    if (S.fontSize) {
      const size = typeof S.fontSize === "number" ? `${S.fontSize}px` : S.fontSize;
      cls += `text-[${size}] `;
      if (styleUsed) styleUsed.fontSize = true;
    }
    if (S.textAlign) {
      const ta = ("" + S.textAlign).toLowerCase();
      if (["left", "center", "right", "justify"].includes(ta)) cls += `text-${ta} `;
      if (styleUsed) styleUsed.textAlign = true;
    }
    if (widget.text?.includes("\n")) cls += "whitespace-pre-line ";
    return cls.trim();
  }

  function styleObjToString(styleObj) {
    return Object.entries(styleObj || {})
      .map(([k, v]) => `${toCamel(k)}: ${JSON.stringify(v)}`)
      .join(", ");
  }

  const widgetMap = {
    Container: "div",
    Button: "button",
    Label: "p",
    Image: "img",
    ImageSeqOpt: "div"
  };

  const byId = {};
  ir.widgets.forEach(w => (byId[w.id] = w));

  const allIds = new Set(ir.widgets.map(w => w.id));
  const childIds = new Set(ir.widgets.flatMap(w => w.children || []));
  const roots = ir.widgets.filter(w => w.type === "Container" && !childIds.has(w.id));
  const rootWidgets = roots.length ? roots : ir.widgets.filter(w => w.type === "Container");

  function render(widget, depth = 2) {
    const pad = " ".repeat(depth);
    const Comp = widgetMap[widget.type] || "div";
    const styleUsed = {};
    const className = widgetToTailwind(widget, styleUsed);

    const styleObj = {};
    if (widget.style) {
      for (const [k, v] of Object.entries(widget.style)) {
        if ((styleUsed && styleUsed[k]) && k !== "color" && k !== "textAlign") continue;
        if (k === "color" && typeof v === "string") styleObj[toCamel(k)] = v.split(" ")[0];
        else if (k === "fontSize" && typeof v === "number") styleObj[toCamel(k)] = `${v}px`;
        else styleObj[toCamel(k)] = v;
      }
    }
    const styleStr = Object.keys(styleObj).length ? ` style={${'{' + styleObjToString(styleObj) + '}'}}` : "";

    const attrs = [`id="${widget.id}"`];
    if (className) attrs.push(`className="${className}"`);

    if (Comp === "img") {
      if (widget.src) attrs.push(`src="${widget.src}" alt="${widget.id}"`);
      return pad + `<${Comp} ${attrs.join(" ")}${styleStr} />`;
    }

    let inner = "";
    if (widget.text) inner += `{${JSON.stringify(widget.text)}}`;
    if (widget.children?.length) {
      const childRenders = widget.children.map(cid => byId[cid] ? "\n" + render(byId[cid], depth + 2) : "").join("");
      inner += childRenders + (childRenders ? `\n${pad}` : "");
    }

    if (inner) {
      return pad + `<${Comp} ${attrs.join(" ")}${styleStr}>\n` + inner + `\n${pad}</${Comp}>`;
    } else {
      return pad + `<${Comp} ${attrs.join(" ")}${styleStr}></${Comp}>`;
    }
  }

  const seen = [];
  const uniqueRoots = rootWidgets.filter(root => {
    const key = JSON.stringify({
      type: root.type,
      layout: root.layout,
      children: root.children,
      text: root.text,
      style: root.style,
      tailwind: root.tailwind
    });
    if (seen.includes(key)) return false;
    seen.push(key);
    return true;
  });

  const body = uniqueRoots.map(root => render(root, 2)).join("\n");

  function indentMultiline(str, spaces = 2) {
    const pad = " ".repeat(spaces);
    return str.split("\n").map(line => pad + line).join("\n");
  }

  return `// Auto-generated by UIBridge. Do not edit manually.\n\nimport React from "react";\n\nconst ${screenName} = () => (\n  <>\n${indentMultiline(body, 2)}\n  </>\n);\n\nexport default ${screenName};\n`;
}
